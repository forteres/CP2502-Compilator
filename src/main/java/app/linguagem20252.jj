options {
    STATIC = false;
}

PARSER_BEGIN(Linguagem20252)
package app;

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import static app.Linguagem20252Constants.*;

public class Linguagem20252 {

    public static int errosSintaticosCount = 0;
    public static int errosLexicosCount = 0;
    public static StringBuilder errosSintaticos = new StringBuilder();

    private TabelaSimbolos tabelaSimbolos;
    private GeradorCodigo geradorCodigo;

    private static int errosSemanticosCount = 0;
    private static StringBuilder errosSemanticos = new StringBuilder();

    private void initSemantica() {
        this.tabelaSimbolos = new TabelaSimbolos();
        this.geradorCodigo  = new GeradorCodigo();
        VariaveisControle.resetarTudo();
        errosSemanticosCount = 0;
        errosSemanticos = new StringBuilder();
    }

    private void adicionarErroSemantico(String msg) {
        errosSemanticosCount++;
        errosSemanticos.append(msg).append("\n");
    }

    public String getListaTokensEsperados(int[][] conjuntoDeTokensEsperados){
        StringBuilder listaTokens = new StringBuilder();
        for (int[] conjunto : conjuntoDeTokensEsperados){
            for (int token : conjunto){
                listaTokens.append(tokenImage[token]).append(" ");
            }
        }
        return listaTokens.toString().trim();
    }

    public static java.util.ArrayList<Token> analiseLexica(InputStream input) throws ParseException {
            errosLexicosCount = 0;

            Linguagem20252 lexer = new Linguagem20252(input);
            java.util.ArrayList<Token> tokens = new java.util.ArrayList<>();
            Token t;

            do {
                t = lexer.getNextToken();

                if(t.kind == Linguagem20252Constants.MALFORMED_IDENTIFIER
                    || t.kind == Linguagem20252Constants.MALFORMED_NUMBER
                    || t.kind == Linguagem20252Constants.MALFORMED_REAL
                    || t.kind == Linguagem20252Constants.INVALID_SIMBOL
                    || t.kind == Linguagem20252Constants.UNCLOSED_QUOTE
                    || t.kind == Linguagem20252Constants.UNCLOSED_STRING
                    || t.kind == Linguagem20252Constants.UNCLOSED_BLOCK_COMMENT){
                    errosLexicosCount++;
                }

                tokens.add(t);
            } while (t.kind != Linguagem20252Constants.EOF);

            return tokens;
        }

    public static StringBuilder analiseSintatica(InputStream input) throws ParseException {
            // Reset de erros sintáticos antes de analisar
            errosSintaticosCount = 0;
            errosSintaticos = new StringBuilder();
            Linguagem20252 parser = new Linguagem20252(input);
            parser.initSemantica();
            parser.Programa();
            // Retorna somente os erros sintáticos coletados
            return errosSintaticos;
    }

    public Token skipToSynchronizingToken(int... synchronizingKinds) {

        if (synchronizingKinds == null || synchronizingKinds.length == 0) {
            synchronizingKinds = new int[] {SEMICOLON, END}; //Se não passar em nada, sincroniza em ';' e 'end'
        }

        Token t = getToken(0);
        int parenDepth = 0; //profundidade de ()
        int bracketDepth = 0; //profundidade de []

        while (true) {
            t = getNextToken();

            if (t.kind == EOF) {
                return t;
            }

            //Atualiza profundidade
            if (t.kind == LPAREN) {
                parenDepth++;
            } else if (t.kind == RPAREN) {
                if (parenDepth > 0) parenDepth--;
            } else if (t.kind == LBRACKET) {
                bracketDepth++;
            } else if (t.kind == RBRACKET) {
                if (bracketDepth > 0) bracketDepth--;
            }

            //Se a profundidade de () e [] for 0 e o token for um dos sincronizadores, retorna o token
            if (parenDepth == 0 && bracketDepth == 0 && isSynchronizingToken(t, synchronizingKinds)) {
                return t;
            }
        }
    }

    private static boolean isSynchronizingToken(Token t, int... synchronizingKinds) {
        if (t == null || synchronizingKinds == null || synchronizingKinds.length == 0) {
            return false;
        }
        int kind = t.kind;
        for (int sk : synchronizingKinds) {
            if (kind == sk) return true;
        }
        return false;
    }
}

PARSER_END(Linguagem20252)



SKIP:
{
< BLANK_SPACE: " ">
| <END_OF_LINE: "\n">
| <NEW_LINE:"\r">
| <TABULATION:"\t">
}

SPECIAL_TOKEN :
{
    < SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    | < BLOCK_COMMENT: "/*" (~["*"] | "*" (~["/"]))* "*/">
    
}

TOKEN: {
        // LITERAIS ------------------------------------------
         < MALFORMED_REAL: (["0"-"9"])((["0"-"9"])?){2}  "." ((["0"-"9"] ["a"-"z","A"-"Z","_"]) | (["a"-"z","A"-"Z","_"] (["0"-"9"])?) (["0"-"9"] | ["a"-"z","A"-"Z","_"])*
        | (["0"-"9"]){2} (["0"-"9"] | ["a"-"z","A"-"Z","_"])+)>
        | < REAL: (["0"-"9"])((["0"-"9"])?){2} "." (["0"-"9"])(["0"-"9"])?>
        | < MALFORMED_NUMBER: ((["0"-"9"]) ((["0"-"9"] ["a"-"z","A"-"Z","_"]) | (["a"-"z","A"-"Z","_"] ["0"-"9"] | ["a"-"z","A"-"Z","_"])) (["0"-"9"])*)
            | (["0"-"9"]){3} (["0"-"9"] | ["a"-"z","A"-"Z","_"])+>
        | < NUMBER: (["0"-"9"])((["0"-"9"])?){2}>
        | < TEXT_DOUBLE: "\"" ( (~["\"","\\","\n","\r"]) | ("\\" ~[]) )* "\"" >
        | < TEXT_SINGLE: "'"  ( (~["'","\\","\n","\r"])  | ("\\" ~[]) )* "'" >
        | < UNCLOSED_STRING: ("\"" | "\'") ( (~["\"", "'","\\","\n","\r"]) | ("\\" ~[]) )+ >
        | < UNCLOSED_QUOTE: ("\"" | "\'") >
        | < UNCLOSED_BLOCK_COMMENT: "/*" (~["*"] | ("*" ~["/"]))*  >
        // SIMBOLOS ESPECIAIS --------------------------------

        | < ASSIGN: "=" >
        | < EQUAL: "==" >
        | < NOT_EQUAL: "!=" >
        | < SEMICOLON: ";" >
        | < COLON: ":" >
        | < COMMA: "," >
        | < DOT: "." >
        | < LBRACE: "{" >
        | < RBRACE: "}" >
        | < LBRACKET: "[" >
        | < RBRACKET: "]" >
        | < LPAREN: "(" >
        | < RPAREN: ")" >
        | < PLUS: "+" >
        | < MINUS: "-" >
        | < STAR: "*" >
        | < SLASH: "/" >
        | < PERCENT: "%" >
        | < POWER: "**" >
        | < DOUBLE_PERCENT: "%%" >
        | < SHIFT_LEFT: "<<" >
        | < SHIFT_RIGHT: ">>" >
        | < SHIFT_LEFT_ASSIGN: "<<=" >
        | < SHIFT_RIGHT_ASSIGN: ">>=" >
        | < EXCLAMATION: "!" >
        | < PIPE: "|" >
        | < AMPERSAND: "&" >

        // TIPOS PRIMITIVOS ----------------------------------

        | < TYPE_NUM:  (("n"|"N")("u"|"U")("m"|"M")) >
        | < TYPE_REAL: (("r"|"R")("e"|"E")("a"|"A")("l"|"L")) >
        | < TYPE_TEXT: (("t"|"T")("e"|"E")("x"|"X")("t"|"T")) >
        | < TYPE_FLAG: (("f"|"F")("l"|"L")("a"|"A")("g"|"G")) >

        // PALAVRAS RESERVADAS -----------------------------------
        | < BEGIN:   (("b"|"B")("e"|"E")("g"|"G")("i"|"I")("n"|"N")) >
        | < DEFINE:  (("d"|"D")("e"|"E")("f"|"F")("i"|"I")("n"|"N")("e"|"E")) >
        | < START:   (("s"|"S")("t"|"T")("a"|"A")("r"|"R")("t"|"T")) >
        | < END:     (("e"|"E")("n"|"N")("d"|"D")) >
        | < SET:     (("s"|"S")("e"|"E")("t"|"T")) >
        | < READ:    (("r"|"R")("e"|"E")("a"|"A")("d"|"D")) >
        | < SHOW:    (("s"|"S")("h"|"H")("o"|"O")("w"|"W")) >
        | < IF:      (("i"|"I")("f"|"F")) >
        | < THEN:    (("t"|"T")("h"|"H")("e"|"E")("n"|"N")) >
        | < ELSE:    (("e"|"E")("l"|"L")("s"|"S")("e"|"E")) >
        | < LOOP:    (("l"|"L")("o"|"O")("o"|"O")("p"|"P")) >
        | < WHILE:   (("w"|"W")("h"|"H")("i"|"I")("l"|"L")("e"|"E")) >

        // FLAG --------------------------------------------------
        | < TRUE:  (("t"|"T")("r"|"R")("u"|"U")("e"|"E")) >
        | < FALSE: (("f"|"F")("a"|"A")("l"|"L")("s"|"S")("e"|"E")) >

        // IDENTIFICADOR -------------------------------------
        | < MALFORMED_IDENTIFIER:
            (["a"-"z","A"-"Z","_"]) (((["a"-"z","A"-"Z","_"])* (["0"-"9"](["0"-"9"])+) (["a"-"z","A"-"Z","_"])*)+
            | (((["a"-"z","A"-"Z","_"])* (["0"-"9"] ["a"-"z","A"-"Z","_"])*)* ["0"-"9"]))
        >
        | < IDENTIFIER: ["a"-"z","A"-"Z","_"] ((["a"-"z","A"-"Z","_"])* (["0"-"9"] ["a"-"z","A"-"Z","_"])*)* >

        // ERRO ----------------------------------------------

        | < INVALID_SIMBOL: ~[]>
}

void Programa() :
{}
{
    try{
        <BEGIN> NomeDoPrograma() BlocoDefine() <START> ListaDeComandos()
        {
            geradorCodigo.gerarInstrucao("STP", 0);
        }
        <END> <DOT>
    } catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);
        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, BEGIN, DEFINE);
    }
}

void NomeDoPrograma() :
{
    Token t = null;
}
{
    try{
        (
            t = <IDENTIFIER>
            {
                tabelaSimbolos.inserir(t.image, 0, 0, "–");
            }
        )?
    } catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);
        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        if (tokensEsperados.contains("IDENTIFIER")){
                errosSintaticos.append("Erro sintático: Nome do Programa deve ser um 'IDENTIFICADOR'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, BEGIN);
    }
}

void Expressao() :
{}
{
    try{
        ExpressaoAritmeticaOuLogica() ExpressaoAux()
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, BEGIN, START, RPAREN, RBRACKET);
    }
}

void ExpressaoAux() :
{}
{
    try{
    (
        <EQUAL> ExpressaoAritmeticaOuLogica()
        | <NOT_EQUAL> ExpressaoAritmeticaOuLogica()
        | <SHIFT_LEFT> ExpressaoAritmeticaOuLogica()
        | <SHIFT_RIGHT> ExpressaoAritmeticaOuLogica()
        | <SHIFT_LEFT_ASSIGN> ExpressaoAritmeticaOuLogica()
        | <SHIFT_RIGHT_ASSIGN> ExpressaoAritmeticaOuLogica()
        )?
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("EQUAL") || tokensEsperados.contains("NOT_EQUAL") || tokensEsperados.contains("SHIFT_LEFT")
            || tokensEsperados.contains("SHIFT_RIGHT") || tokensEsperados.contains("SHIFT_LEFT_ASSIGN") || tokensEsperados.contains("SHIFT_RIGHT_ASSIGN"))
        {
            errosSintaticos.append("Erro sintático: A Expressão deve conter um operador lógico").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, RPAREN, RBRACKET, START);
    }
}

void ExpressaoAritmeticaOuLogica() :
{}
{
    try{
        Termo2() MenorPrioridade()
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, RPAREN, RBRACKET, START);
    }
}

void MenorPrioridade() :
{}
{
    try{
        (
            <PLUS> Termo2() MenorPrioridade()
            | <MINUS> Termo2() MenorPrioridade()
            | <PIPE> Termo2() MenorPrioridade()
        )?
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("PLUS") || tokensEsperados.contains("MINUS") || tokensEsperados.contains("PIPE")){
            errosSintaticos.append("Erro sintático: A Expressão deve conter um operador aritmético").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET);
    }
}

void Termo2() :
{}
{
    try{
        Termo1() MediaPrioridade()
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET);
    }
}

void MediaPrioridade() :
{}
{
    try{
        (
            <STAR> Termo1() MediaPrioridade()
          | <SLASH> Termo1() MediaPrioridade()
          | <PERCENT> Termo1() MediaPrioridade()
          | <DOUBLE_PERCENT> Termo1() MediaPrioridade()
          | <AMPERSAND> Termo1() MediaPrioridade()
        )?
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("STAR") || tokensEsperados.contains("SLASH") || tokensEsperados.contains("PERCENT")
            || tokensEsperados.contains("DOUBLE_PERCENT") || tokensEsperados.contains("AMPERSAND"))
        {
            errosSintaticos.append("Erro sintático: A Expressão deve conter um operador aritmético").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET);
    }
}

void Termo1() :
{}
{
    try{
        Elemento() MaiorPrioridade()
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET);
    }
}

void MaiorPrioridade() :
{}
{
    try{
        (
            <POWER> Elemento() MaiorPrioridade()
        )?
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("POWER")){
             errosSintaticos.append("Erro sintático: A Expressão deve conter o operador '**'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET);
    }
}

void Elemento() :
{}
{
    try{
      <IDENTIFIER> SufixoIdentificador()
      | <NUMBER>
      | <REAL>
      | <TEXT_DOUBLE> | <TEXT_SINGLE>  // constante literal com "" e com ''
      | <TRUE>
      | <FALSE>
      | <LPAREN> Expressao() <RPAREN>
      | <EXCLAMATION> <LPAREN> Expressao() <RPAREN>
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if (tokensEsperados.contains("IDENTIFIER") || tokensEsperados.contains("NUMBER") || tokensEsperados.contains("REAL") || tokensEsperados.contains("TEXT_DOUBLE")
            || tokensEsperados.contains("TEXT_SINGLE") || tokensEsperados.contains("TRUE") || tokensEsperados.contains("FALSE"))
        {
            errosSintaticos.append("Erro sintático: Elemento deve pertencer ao conjunto: {'Identificador', 'Constante numérica', 'Constante numérica real', 'Constante literal', 'TRUE' ou 'FALSE'}").append("\n\n");
        }else if (tokensEsperados.contains("LPAREN") || tokensEsperados.contains("RPAREN")){
            errosSintaticos.append("Erro sintático: Elemento deve estar entre '(' e ')'").append("\n\n");
        }else if (tokensEsperados.contains("EXCLAMATION")){
            errosSintaticos.append("Erro sintático: Elemento deve estar entre '!(' e ')'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET, LPAREN, LBRACKET);
    }
}

void ListaDeElementos() :
{}
{
    try{
        Elemento() ListaDeElementosAux()
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET, COMMA);
    }
}

void ListaDeElementosAux() : // pode ter erro aqui
{}
{
    try{
        (
            <COMMA> Elemento() ListaDeElementosAux()
        )?
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("COMMA")){
             errosSintaticos.append("Erro sintático: Elementos devem estar separados por ','").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, RPAREN, RBRACKET, COMMA);
    }
}

void ListaIdentificadores() :
{}
{
    try{
        <IDENTIFIER> ListaIdentificadoresAux()
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("IDENTIFIER")){
             errosSintaticos.append("Erro sintático: Deve conter ao menos um 'Identificador'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, COMMA);
    }
}

void ListaIdentificadoresAux() :
{}
{
    try{
        (
            <COMMA> <IDENTIFIER> ListaIdentificadoresAux()
        )?
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("COMMA")){
             errosSintaticos.append("Erro sintático: Elementos devem estar separados por ','").append("\n\n");
        }else if(tokensEsperados.contains("IDENTIFIER")){
            errosSintaticos.append("Erro sintático: Deve conter ao menos um 'Identificador' após a ','").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, COMMA);
    }
}

void Variavel() :
{}
{
    try{
        ListaIdentificadores() <COLON> DeclaracaoTipo() <SEMICOLON>
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("COLON")){
             errosSintaticos.append("Erro sintático: Declaração de variável deve conter ':' após a lista de variáveis").append("\n\n");
        }else if(tokensEsperados.contains("SEMICOLON")){
            errosSintaticos.append("Erro sintático: Declaração da variável deve terminar com ';' após especificação do tipo").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START);
    }
}

//<tipo> ::= num #T | real #T | text #T | flag #T
//#T — categoriaAtual ← 1/2/3/4.

void Tipo() :
{}
{
    try{
        (
            <TYPE_NUM> { VariaveisControle.categoriaAtual = 1; }
            | <TYPE_REAL> { VariaveisControle.categoriaAtual = 2; }
            | <TYPE_TEXT> { VariaveisControle.categoriaAtual = 3; }
            | <TYPE_FLAG> { VariaveisControle.categoriaAtual = 4; }
        )
    } catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("TYPE_NUM") || tokensEsperados.contains("TYPE_REAL") || tokensEsperados.contains("TYPE_TEXT") || tokensEsperados.contains("TYPE_FLAG")){
             errosSintaticos.append("Erro sintático: Tipo declarado deve pertencer ao conjunto: {'NUM', 'REAL' 'TEXT' 'FLAG'}").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, COLON);
    }
}

void DeclaracaoTipo() :
{}
{
    try{
        Tipo() SufixoDoTipo()
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);
        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, START, ASSIGN);
    }
}

void SufixoDoTipo() :
{}
{
    try{
    (
        <ASSIGN> Elemento()
      | DeclaracaoArray()
    )?
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("=")){
            errosSintaticos.append("Erro sintático: Atribuições devem ser feitas a partir do simbolo '='").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START);
    }
}

void DeclaracaoArray() : // Talvez esses erros sejam tratados lá no Delcaração Tipo
{}
{
    try{
        <LBRACKET> <NUMBER> <RBRACKET> DeclaracaoValoresArray()
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("[") || tokensEsperados.contains("]")){
            errosSintaticos.append("Erro sintático: Declaração de tamanho do array deve ser feita entre '[' e ']'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, RBRACKET);
    }
}

void DeclaracaoValoresArray() : // Talvez contains("=") seja na DeclaraçãoArray
{}
{
    try{
    (
        <ASSIGN> <LBRACE> ListaDeElementos() <RBRACE>
    )?
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("=")){
            errosSintaticos.append("Erro sintático: Atribuições devem ser feitas a partir do simbolo '='").append("\n\n");
        }
        if(tokensEsperados.contains("{") || tokensEsperados.contains("}")){
            errosSintaticos.append("Erro sintático: Declarações de valores dentro de arrays devem ser feitas entre '{' e '}'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START, RBRACE);
    }
}

void ListaDeVariaveis() :
{}
{
    try{
        Variavel() ListaDeVariaveisAux()
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains(";")){
            errosSintaticos.append("Erro sintático: Declarações de variáveis devem ser separadas por ';'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, START);
    }
}

void ListaDeVariaveisAux() :
{}
{
    try{
    (
        Variavel() ListaDeVariaveisAux()
    )?
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, START);
    }
}

void BlocoDefine() :
{}
{
    try{
    (
        <DEFINE> ListaDeVariaveis()
    )?
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, START);
    }
}

void Atribuicao() :
{
    Token t = null;
}
{
    try{
        <SET> t = <IDENTIFIER>
        {
            TabelaSimbolos.Simbolo simbolo = tabelaSimbolos.buscar(t.image);
            if(simbolo == null){
                adicionarErroSemantico("Identificador não declarado: " + t.image);
            } else {
                VariaveisControle.identificadorAtual = t.image;
                VariaveisControle.categoriaAtual_id = simbolo.categoria;
                VariaveisControle.baseAtual = simbolo.base;
                VariaveisControle.tamanhoAtual = simbolo.tamanho;
                VariaveisControle.temIndice = false;
            }
        }
        SufixoDaAtribuicao()
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP);
    }
}

void SufixoDaAtribuicao() :
{}
{
    try{
        <ASSIGN> Expressao()
        {
            boolean isVetor = !VariaveisControle.tamanhoAtual.equals("–");
            if (!isVetor && VariaveisControle.temIndice) {
                adicionarErroSemantico("Escalar não aceita índice: " + VariaveisControle.identificadorAtual);
            } else if (isVetor && !VariaveisControle.temIndice) {
                adicionarErroSemantico("Vetor exige índice: " + VariaveisControle.identificadorAtual);
            }

            if (VariaveisControle.tamanhoAtual.equals("–")) {
                geradorCodigo.gerarInstrucao("STR", VariaveisControle.baseAtual);
            } else {
                geradorCodigo.gerarInstrucao("STX", 0);
            }
        }
    | <LBRACKET> Expressao()
        {
            VariaveisControle.temIndice = true;
            geradorCodigo.gerarInstrucao("LDI", VariaveisControle.baseAtual - 1);
            geradorCodigo.gerarInstrucao("ADD", 0);
        }
        <RBRACKET> <ASSIGN> Expressao()
        {
            boolean isVetor = !VariaveisControle.tamanhoAtual.equals("–");
            if (!isVetor && VariaveisControle.temIndice) {
                adicionarErroSemantico("Escalar não aceita índice: " + VariaveisControle.identificadorAtual);
            } else if (isVetor && !VariaveisControle.temIndice) {
                adicionarErroSemantico("Vetor exige índice: " + VariaveisControle.identificadorAtual);
            }

            geradorCodigo.gerarInstrucao("STX", 0);

        }

    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

         if(tokensEsperados.contains("=")){
            errosSintaticos.append("Erro sintático: Atribuições devem ser feitas a partir do simbolo '='").append("\n\n");
         }
         if(tokensEsperados.contains("[") || tokensEsperados.contains("]")){
            errosSintaticos.append("Erro sintático: Para atribuir um valor a uma posição de um array, deve se seguir o formato <variavel>[<indice>] = <valor atribuido>").append("\n\n");
         }
         skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP, RBRACKET);
    }

}

void EntradaDeDados() :
{}
{
    try{
        <READ> <LPAREN> <IDENTIFIER> SufixoIdentificador() <RPAREN>
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("(") || tokensEsperados.contains(")")){
            errosSintaticos.append("Erro sintático: A variavel destino da entrada de dados deve ser especificada entre '(' e')')").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP, RPAREN);
    }
}

void SufixoIdentificador() : // talvez o contains("[") seja no Entrada de dados
{}
{
    try{
        (
            <LBRACKET> Expressao() <RBRACKET>
        )?
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("[") || tokensEsperados.contains("]")){
            errosSintaticos.append("Erro sintático: Indices de vetores devem ser explicitos entre '[' e ']' ").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP, RBRACKET);
    }
}

void SaidaDeDados() :
{}
{
    try{
        <SHOW> <LPAREN> ListaDeElementos() <RPAREN>
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("(") || tokensEsperados.contains(")")){
            errosSintaticos.append("Erro Sintatico: O conteudo a ser mostrado deve estar entre '(' e ')'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP, RPAREN);
    }
}

void Selecao() :
{}
{
    try{
        <IF> Expressao() <THEN> ListaDeComandos() Else() <END>
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("IF") || tokensEsperados.contains("THEN") || tokensEsperados.contains("END")){
            errosSintaticos.append("Erro sintático: Comandos de seleção devem ter seguir o formato 'IF <condição> THEN <comandos> END'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP, THEN);
    }
}

void Else() :
{}
{
    try{
        (
            <ELSE> ListaDeComandos()
        )?
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("ELSE")){
            errosSintaticos.append("Erro sintático: O comando 'Se não' se inicia através de comando 'ELSE'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP, THEN);
    }
}

void Repeticao() :
{}
{
    try{
        <LOOP> <WHILE> Expressao() ListaDeComandos() <END>
    }catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("LOOP") || tokensEsperados.contains("WHILE") || tokensEsperados.contains("END")){
            errosSintaticos.append("Erro sintático: Comandos de repetição devem seguir o formato 'LOOP WHILE <comandos> END").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP);
    }
}

void Comando() :
{}
{
    try{
        Atribuicao()
      | EntradaDeDados()
      | SaidaDeDados()
      | Selecao()
      | Repeticao()
    } catch(ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("SET") || tokensEsperados.contains("READ") || tokensEsperados.contains("SHOW") || tokensEsperados.contains("IF") ||  tokensEsperados.contains("LOOP")){
            errosSintaticos.append("Erro sintático: Comando não especificado ou especificado errado, os comandos são: SET, READ, SHOW, IF, LOOP").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP);
    }
}

void ListaDeComandos() :
{}
{
    try{
        Comando() <SEMICOLON> ListaDeComandosAux()
    } catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        if (tokensEsperados.contains(";")){
            errosSintaticos.append("Erro sintático: Todo comando deve ser finalizado com ';'").append("\n\n");
        }
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP);
    }
}

void ListaDeComandosAux() :
{}
{
    try{
    (
        Comando() <SEMICOLON> ListaDeComandosAux()
    )?
    } catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        skipToSynchronizingToken(SEMICOLON, END, READ, SHOW, IF, LOOP);
    }
}
