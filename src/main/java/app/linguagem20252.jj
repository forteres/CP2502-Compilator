options {
    STATIC = false;
}

PARSER_BEGIN(Linguagem20252)
package app;

import java.io.InputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import static app.Linguagem20252Constants.*;

public class Linguagem20252 {

    public static int errosSemanticosCount = 0;
    public static int errosSintaticosCount = 0;
    public static int errosLexicosCount = 0;
    public static StringBuilder errosSintaticos = new StringBuilder();
    public static StringBuilder errosSemanticos = new StringBuilder();

    private AnalisadorSemantico analisadorSemantico = new AnalisadorSemantico();

    public String getListaTokensEsperados(int[][] conjuntoDeTokensEsperados){
        StringBuilder listaTokens = new StringBuilder();
        for (int[] conjunto : conjuntoDeTokensEsperados){
            for (int token : conjunto){
                String descricao = OutputDictionary.getCategory(token);

                if (descricao.isEmpty()) {
                    descricao = tokenImage[token];
                }
                listaTokens.append(descricao).append(" ");
            }
        }
        return listaTokens.toString().trim();
    }

    public static java.util.ArrayList analiseLexica(InputStream input) throws ParseException {
            errosLexicosCount = 0;
            Linguagem20252 lexer = new Linguagem20252(input);
            java.util.ArrayList tokens = new java.util.ArrayList();
            Token token;
            do {
                token = lexer.getNextToken();
                if(token.kind == Linguagem20252Constants.MALFORMED_IDENTIFIER
                    || token.kind == Linguagem20252Constants.MALFORMED_NUMBER
                    || token.kind == Linguagem20252Constants.MALFORMED_REAL
                    || token.kind == Linguagem20252Constants.INVALID_SIMBOL
                    || token.kind == Linguagem20252Constants.UNCLOSED_QUOTE
                    || token.kind == Linguagem20252Constants.UNCLOSED_STRING
                    || token.kind == Linguagem20252Constants.UNCLOSED_BLOCK_COMMENT){
                    tokens.add(token);
                    errosLexicosCount++;
                }
            } while (token.kind != Linguagem20252Constants.EOF);

            return tokens;
        }

    public static StringBuilder analiseSintatica(InputStream input) throws ParseException {
            Linguagem20252 parser = new Linguagem20252(input);
            errosSintaticosCount = 0;
            errosSintaticos = new StringBuilder();
            parser.Programa();
            return errosSintaticos;
    }

    public Token skipToSynchronizingToken(int... synchronizingKinds) {
        Token t = getToken(1);

        while (t.kind != EOF && !isSynchronizingToken(t, synchronizingKinds)) {
            t = getNextToken();
        }

        return getToken(1);
    }

    private static boolean isSynchronizingToken(Token t, int... synchronizingKinds) {
        for (int kind : synchronizingKinds) {
            if (t.kind == kind) return true;
        }
        return false;
    }

    boolean isEOF() {
        return getToken(1).kind == EOF;
    }

    private void executarAcaoSemantica(Runnable acao) {
            try {
                acao.run();
            } catch (IllegalArgumentException e) {
                errosSemanticosCount++;
                errosSemanticos.append("Erro semântico na linha " + getToken(1).beginLine + ", coluna " + getToken(1).beginColumn + ": " + e.getMessage() + "\n\n");
            } catch (Exception e) {
                errosSemanticosCount++;
                errosSemanticos.append("Erro semântico inesperado na linha " + getToken(1).beginLine + ", coluna " + getToken(1).beginColumn + ": " + e.getMessage() + "\n\n");
            }
        }

    public ArrayList<Triplet<Integer, String, Object>> getCodigoIntermediario() {
            return analisadorSemantico.getListaDeInstrucoes();
        }


}

PARSER_END(Linguagem20252)



SKIP:
{
< BLANK_SPACE: " ">
| <END_OF_LINE: "\n">
| <NEW_LINE:"\r">
| <TABULATION:"\t">
}

SPECIAL_TOKEN :
{
    < SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    | < BLOCK_COMMENT: "/*" (~["*"] | "*" (~["/"]))* "*/">
    
}

TOKEN: {
        // LITERAIS ------------------------------------------
         < MALFORMED_REAL: (["0"-"9"])((["0"-"9"])?){2}  "." ((["0"-"9"] ["a"-"z","A"-"Z","_"]) | (["a"-"z","A"-"Z","_"] (["0"-"9"])?) (["0"-"9"] | ["a"-"z","A"-"Z","_"])*
        | (["0"-"9"]){2} (["0"-"9"] | ["a"-"z","A"-"Z","_"])+)>
        | < REAL: (["0"-"9"])((["0"-"9"])?){2} "." (["0"-"9"])(["0"-"9"])?>
        | < MALFORMED_NUMBER: ((["0"-"9"]) ((["0"-"9"] ["a"-"z","A"-"Z","_"]) | (["a"-"z","A"-"Z","_"] ["0"-"9"] | ["a"-"z","A"-"Z","_"])) (["0"-"9"])*)
            | (["0"-"9"]){3} (["0"-"9"] | ["a"-"z","A"-"Z","_"])+>
        | < NUMBER: (["0"-"9"])((["0"-"9"])?){2}>
        | < TEXT_DOUBLE: "\"" ( (~["\"","\\","\n","\r"]) | ("\\" ~[]) )* "\"" >
        | < TEXT_SINGLE: "'"  ( (~["'","\\","\n","\r"])  | ("\\" ~[]) )* "'" >
        | < UNCLOSED_STRING: ("\"" | "\'") ( (~["\"", "'","\\","\n","\r"]) | ("\\" ~[]) )+ >
        | < UNCLOSED_QUOTE: ("\"" | "\'") >
        | < UNCLOSED_BLOCK_COMMENT: "/*" (~["*"] | ("*" ~["/"]))*  >
        // SIMBOLOS ESPECIAIS --------------------------------

        | < ASSIGN: "=" >
        | < EQUAL: "==" >
        | < NOT_EQUAL: "!=" >
        | < SEMICOLON: ";" >
        | < COLON: ":" >
        | < COMMA: "," >
        | < DOT: "." >
        | < LBRACE: "{" >
        | < RBRACE: "}" >
        | < LBRACKET: "[" >
        | < RBRACKET: "]" >
        | < LPAREN: "(" >
        | < RPAREN: ")" >
        | < PLUS: "+" >
        | < MINUS: "-" >
        | < STAR: "*" >
        | < SLASH: "/" >
        | < PERCENT: "%" >
        | < POWER: "**" >
        | < DOUBLE_PERCENT: "%%" >
        | < SHIFT_LEFT: "<<" >
        | < SHIFT_RIGHT: ">>" >
        | < SHIFT_LEFT_ASSIGN: "<<=" >
        | < SHIFT_RIGHT_ASSIGN: ">>=" >
        | < EXCLAMATION: "!" >
        | < PIPE: "|" >
        | < AMPERSAND: "&" >

        // TIPOS PRIMITIVOS ----------------------------------

        | < TYPE_NUM:  (("n"|"N")("u"|"U")("m"|"M")) >
        | < TYPE_REAL: (("r"|"R")("e"|"E")("a"|"A")("l"|"L")) >
        | < TYPE_TEXT: (("t"|"T")("e"|"E")("x"|"X")("t"|"T")) >
        | < TYPE_FLAG: (("f"|"F")("l"|"L")("a"|"A")("g"|"G")) >

        // PALAVRAS RESERVADAS -----------------------------------
        | < BEGIN:   (("b"|"B")("e"|"E")("g"|"G")("i"|"I")("n"|"N")) >
        | < DEFINE:  (("d"|"D")("e"|"E")("f"|"F")("i"|"I")("n"|"N")("e"|"E")) >
        | < START:   (("s"|"S")("t"|"T")("a"|"A")("r"|"R")("t"|"T")) >
        | < END:     (("e"|"E")("n"|"N")("d"|"D")) >
        | < SET:     (("s"|"S")("e"|"E")("t"|"T")) >
        | < READ:    (("r"|"R")("e"|"E")("a"|"A")("d"|"D")) >
        | < SHOW:    (("s"|"S")("h"|"H")("o"|"O")("w"|"W")) >
        | < IF:      (("i"|"I")("f"|"F")) >
        | < THEN:    (("t"|"T")("h"|"H")("e"|"E")("n"|"N")) >
        | < ELSE:    (("e"|"E")("l"|"L")("s"|"S")("e"|"E")) >
        | < LOOP:    (("l"|"L")("o"|"O")("o"|"O")("p"|"P")) >
        | < WHILE:   (("w"|"W")("h"|"H")("i"|"I")("l"|"L")("e"|"E")) >

        // FLAG --------------------------------------------------
        | < TRUE:  (("t"|"T")("r"|"R")("u"|"U")("e"|"E")) >
        | < FALSE: (("f"|"F")("a"|"A")("l"|"L")("s"|"S")("e"|"E")) >

        // IDENTIFICADOR -------------------------------------
        | < MALFORMED_IDENTIFIER:
            (["a"-"z","A"-"Z","_"]) (((["a"-"z","A"-"Z","_"])* (["0"-"9"](["0"-"9"])+) (["a"-"z","A"-"Z","_"])*)+
            | (((["a"-"z","A"-"Z","_"])* (["0"-"9"] ["a"-"z","A"-"Z","_"])*)* ["0"-"9"]))
        >
        | < IDENTIFIER: ["a"-"z","A"-"Z","_"] ((["a"-"z","A"-"Z","_"])* (["0"-"9"] ["a"-"z","A"-"Z","_"])*)* >

        // ERRO ----------------------------------------------

        | < INVALID_SIMBOL: ~[]>
}


// # PROGRAMA
void Programa() :
{}
{
    try{
        <BEGIN> NomeDoPrograma() BlocoDefine() BlocoStart() BlocoEnd()
    } catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if (tokensEsperados.contains("begin")){
            errosSintaticos.append("Erro sintático: Programa deve iniciar com 'BEGIN'").append("\n\n");
        }
        Token t = getToken(1);
        if (t.kind == EOF){
            errosSintaticos.append("Erro sintático: Fim inesperado do programa.").append("\n\n");
        }
        // RECUPERAÇÃO DE ERROS
        skipToSynchronizingToken(END, START, DEFINE);
        t = getToken(1);
        if (t.kind == END){
            BlocoEnd();
        }else if (t.kind == START){
            BlocoStart(); BlocoEnd(); // talvez try catch em cada um, acho que nao
        }else if (t.kind == DEFINE){
            BlocoDefine(); BlocoStart(); BlocoEnd();
        }
    }
}

void NomeDoPrograma() :
{Token t;}
{
    (
    t=<IDENTIFIER> { executarAcaoSemantica(() -> analisadorSemantico.P1(t.image));}
    )?
}

void BlocoDefine() :
{}
{
    (
        <DEFINE> {executarAcaoSemantica(() -> analisadorSemantico.D0());} ListaDeVariaveis()
    )?
}

void BlocoStart() :
{}
{
    try{
        <START> ListaDeComandos() /* semantica*/
    }catch (ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if (tokensEsperados.contains("start")){
            errosSintaticos.append("Erro sintático: Seção de comandos deve iniciar com 'START'").append("\n\n");
        }

        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP, END);
        Token t = getToken(1);
        if (t.kind != END){ // se achar END, desempilha
            ListaDeComandos() /* semantica*/; // talvez try catch? nao acho que precisa
        }
    }
}

void BlocoEnd() :
{}
{
    try{
        <END> <DOT>
    }catch (ParseException e){
        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if (tokensEsperados.contains("end") || tokensEsperados.contains("DOT")) {
            errosSintaticos.append("Erro sintático: Programa deve acabar com 'END.'").append("\n\n");
        }
    }
}

// DECLARACOES

void ListaDeVariaveis() :
{}
{
    Variavel() ListaDeVariaveisAux()
}

void ListaDeVariaveisAux() :
{}
{
    (
        Variavel() ListaDeVariaveisAux()
    )?
}

void Variavel() :
{}
{
    try{
        ListaIdentificadores() <COLON> Tipo() DeclaracaoArray() <SEMICOLON> {executarAcaoSemantica(() -> analisadorSemantico.D6());}
    }catch (ParseException e){
        if(isEOF()){throw e;}

        Token t = getToken(1);
        if(t.kind != START && t.kind != IDENTIFIER && t.kind != EOF){
            errosSintaticosCount++;
            String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

            TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

            if(tokensEsperados.contains(":")){
                 errosSintaticos.append("Erro sintático: Declaração de variável deve conter ':' após a lista de variáveis").append("\n\n");
            }else if(tokensEsperados.contains(";")){
                errosSintaticos.append("Erro sintático: Declaração da variável deve terminar com ';' após especificação do tipo").append("\n\n");
            }
            skipToSynchronizingToken(IDENTIFIER, START);
        }
    }
}

void ListaIdentificadores() :
{Token t;}
{
    try{
        t=<IDENTIFIER> {executarAcaoSemantica(() -> analisadorSemantico.D1(t.image));} ListaIdentificadoresAux()
    }catch (ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);
        errosSintaticos.append("Erro sintático: O bloco 'Define' deve conter ao menos uma declaração de variável (identificador : tipo ;)").append("\n\n");

        skipToSynchronizingToken(START, COLON, IDENTIFIER);
    }
}

void ListaIdentificadoresAux() :
{Token t;}
{
    try{
        (
            <COMMA> t=<IDENTIFIER> {executarAcaoSemantica(() -> analisadorSemantico.D1(t.image));} ListaIdentificadoresAux()
        )?
    }catch (ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains(",")){
             errosSintaticos.append("Erro sintático: Elementos declarados devem estar separados por ','").append("\n\n");
        }else if(tokensEsperados.contains("identificador")){
            errosSintaticos.append("Erro sintático: Deve conter ao menos um 'Identificador' após a ','").append("\n\n");
        }
        skipToSynchronizingToken(COMMA, START, COLON, IDENTIFIER);

        Token t = getToken(1);
        if(t.kind == COMMA){
            ListaIdentificadoresAux();
        }
    }
}

void Tipo() :
{}
{
    try{
         <TYPE_NUM> /* semantica*/
        | <TYPE_REAL> /* semantica*/
        | <TYPE_TEXT> /* semantica*/
        | <TYPE_FLAG> /* semantica*/
    }catch (ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("numero inteiro") || tokensEsperados.contains("numero real") || tokensEsperados.contains("texto") || tokensEsperados.contains("constante logica")){
             errosSintaticos.append("Erro sintático: Tipo declarado deve pertencer ao conjunto: {'NUM', 'REAL', 'TEXT', 'TRUE', 'FALSE'}").append("\n\n");
        }
        Token t = skipToSynchronizingToken(LBRACKET, START, IDENTIFIER);

        if(t.kind == IDENTIFIER | t.kind == START){
            throw new ParseException("Sincronizado com identificador ou start dentro de Tipo()");
        }
    }
}

void DeclaracaoArray() :
{}
{
    try{
        <LBRACKET> <NUMBER> /* semantica*/ <RBRACKET> DeclaracaoValoresArray() /* semantica*/ | DeclaracaoValoresEscalar() /* semantica*/
    }catch(ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("[") || tokensEsperados.contains("]")){
            errosSintaticos.append("Erro sintático: Declaração de tamanho do array deve ser feita entre '[' e ']'").append("\n\n");
        }
        // else aqui para <number>?
        skipToSynchronizingToken(IDENTIFIER, START, ASSIGN);

        Token t = getToken(1);
        if(t.kind == ASSIGN) {
            DeclaracaoValoresArray() /* semantica*/;
        }
    }
}

void DeclaracaoValoresArray() :
{}
{
    try{
    (
        <ASSIGN> <LBRACE> ListaDeValoresVetor() <RBRACE> /* semantica*/
    )?
    }catch(ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("=")){
            errosSintaticos.append("Erro sintático: Atribuições devem ser feitas a partir do simbolo '='").append("\n\n");
        }
        if(tokensEsperados.contains("{") || tokensEsperados.contains("}")){
            errosSintaticos.append("Erro sintático: Declarações de valores dentro de arrays devem ser feitas entre '{' e '}'").append("\n\n");
        }
        skipToSynchronizingToken(START, IDENTIFIER);
    }
}

void DeclaracaoValoresEscalar() :
{}
{
    (
        <ASSIGN> Valor() /* semantica*/
    )?
}

void ListaDeValoresVetor() :
{}
{
    Valor() /* semantica*/ ListaDeValoresVetorAux()
}

void ListaDeValoresVetorAux() :
{}
{
    (
        <COMMA> Valor() /* semantica*/ ListaDeValoresVetorAux()
    )?
}

void Valor() :
{}
{
    try{
       <NUMBER> /* semantica*/
      | <REAL> /* semantica*/
      | <TEXT_DOUBLE> /* semantica*/| <TEXT_SINGLE> /* semantica*/ // constante literal com "" e com ''
      | <TRUE> /* semantica*/
      | <FALSE> /* semantica*/
    }catch (ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if (tokensEsperados.contains("numero inteiro") || tokensEsperados.contains("numero real") || tokensEsperados.contains("texto")
           || tokensEsperados.contains("constante logica"))
        {
            errosSintaticos.append("Erro sintático: Elemento deve pertencer ao conjunto: {'Constante numérica', 'Constante numérica real', 'Constante literal', 'TRUE' ou 'FALSE'}").append("\n\n");
        }
        skipToSynchronizingToken(COMMA, START, IDENTIFIER);
    }
}

// COMANDOS

void ListaDeComandos() :
{}
{
    Comando() ListaDeComandosAux()
}

void ListaDeComandosAux() :
{}
{
    (
        Comando() ListaDeComandosAux()
    )?
}

void Comando() :
{}
{
        Atribuicao()
      | EntradaDeDados()
      | SaidaDeDados()
      | Selecao()
      | Repeticao()
}

void Atribuicao() :
{}
{
    try{
        <SET> <IDENTIFIER> /* semantica*/ Indice() /* semantica*/ <ASSIGN> Expressao() /* semantica*/ <SEMICOLON>
    }catch(ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        errosSintaticos.append("Erro sintático: Comando de atribuição deve seguir a sintaxe: 'set identificador[indice]/identificador = (valor ou expressão);'").append("\n\n");

        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP);

    }
}

void Indice() :
{}
{
    try{
    (
        <LBRACKET> Expressao()  /* semantica*/ <RBRACKET>
    )?
    }catch(ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        errosSintaticos.append("Erro sintático: Indice deve estar entre '[' e ']'").append("\n\n");

        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP);
    }
}

void EntradaDeDados() :
{}
{
    try{
        <READ> <LPAREN> <IDENTIFIER> /* semantica*/ Indice() /* semantica*/<RPAREN> <SEMICOLON>
    }catch(ParseException e){
        if(isEOF()){throw e;}
        errosSintaticosCount++;

        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        errosSintaticos.append("Erro sintático: Comando de entrada de dados deve seguir a sintaxe: 'READ(identificador/identificador[indice]);'").append("\n\n");

        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP);
    }
}

void SaidaDeDados() :
{}
{
    try{
        <SHOW> <LPAREN> ListaDeSaida() <RPAREN> <SEMICOLON>
    }catch(ParseException e){
        if(isEOF()){throw e;}
        errosSintaticosCount++;

        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        errosSintaticos.append("Erro Sintatico: Comando de saida de dados deve seguir a sintaxe: 'SHOW(identificador/identificador[indice]);' ou\n\t 'SHOW(valor/valor,valor)'").append("\n\n");

        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP);
    }
}

void ListaDeSaida() :
{}
{
    Item() ListaDeSaidaAux()
}

void ListaDeSaidaAux() :
{}
{
    (
        <COMMA> Item() ListaDeSaidaAux()
    )?
}

void Item() :
{}
{
    try{
        <IDENTIFIER>  /* semantica*/ Indice() /* semantica*/
        | <NUMBER> /* semantica*/
        | <REAL> /* semantica*/
        | <TEXT_DOUBLE> /* semantica*/ | <TEXT_SINGLE> /* semantica*/
    }catch(ParseException e){
        if(isEOF()){throw e;}
        errosSintaticosCount++;

        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP, COMMA, RPAREN);
    }
}

void Selecao() :
{}
{
    try{
        <IF> Expressao() /* semantica*/ <THEN> ListaDeComandos() Else() /* semantica*/ <END> <SEMICOLON>
    }catch(ParseException e){
        if(isEOF()){throw e;}
        errosSintaticosCount++;

        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        errosSintaticos.append("Erro sintático: Comando de seleção deve seguir a sintaxe: 'IF <condição> THEN <comandos> END'").append("\n\n");

        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP);
    }
}

void Else() :
{}
{
    (
        <ELSE> /* semantica*/ ListaDeComandos()
    )?
}

void Repeticao() :
{}
{
    try{
        <LOOP> <WHILE> Expressao() /* semantica*/ ListaDeComandos() /* semantica*/ <END> <SEMICOLON>
    }catch(ParseException e){
        if(isEOF()){throw e;}
        errosSintaticosCount++;

        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if(tokensEsperados.contains("loop") || tokensEsperados.contains("while") || tokensEsperados.contains("end")){
            errosSintaticos.append("Erro sintático: Comando de repetição devem a sintaxe: 'LOOP WHILE <comandos> END").append("\n\n");
        }
        skipToSynchronizingToken(SET, READ, SHOW, IF, LOOP);
    }
}

// EXPRESSAO

void Expressao() :
{}
{
    ExpressaoAritmeticaOuLogica() ExpressaoAux()
}

void ExpressaoAux() :
{}
{
    (
          <EQUAL> ExpressaoAritmeticaOuLogica() /* semantica*/
        | <NOT_EQUAL> ExpressaoAritmeticaOuLogica() /* semantica*/
        | <SHIFT_LEFT> ExpressaoAritmeticaOuLogica() /* semantica*/
        | <SHIFT_RIGHT> ExpressaoAritmeticaOuLogica() /* semantica*/
        | <SHIFT_LEFT_ASSIGN> ExpressaoAritmeticaOuLogica() /* semantica*/
        | <SHIFT_RIGHT_ASSIGN> ExpressaoAritmeticaOuLogica() /* semantica*/
    )?
}

void ExpressaoAritmeticaOuLogica() :
{}
{
    Termo2() MenorPrioridade()
}

void MenorPrioridade() :
{}
{
    (
          <PLUS> Termo2() /* semantica*/ MenorPrioridade()
        | <MINUS> Termo2() /* semantica*/ MenorPrioridade()
        | <PIPE> Termo2() /* semantica*/ MenorPrioridade()
    )?
}

void Termo2() :
{}
{
    Termo1() MediaPrioridade()
}

void MediaPrioridade() :
{}
{
    (
        <STAR> Termo1() /* semantica*/ MediaPrioridade()
      | <SLASH> Termo1() /* semantica*/ MediaPrioridade()
      | <PERCENT> Termo1() /* semantica*/ MediaPrioridade()
      | <DOUBLE_PERCENT> Termo1() /* semantica*/ MediaPrioridade()
      | <AMPERSAND> Termo1() /* semantica*/ MediaPrioridade()
    )?
}

void Termo1() :
{}
{
    Elemento() MaiorPrioridade()
}

void MaiorPrioridade() :
{}
{
    (
        <POWER> Elemento() /* semantica*/ MaiorPrioridade()
    )?
}

void Elemento() :
{}
{
    try{
      <IDENTIFIER> /* semantica*/ Indice() /* semantica*/
      | <NUMBER> /* semantica*/
      | <REAL> /* semantica*/
      | <TEXT_DOUBLE> /* semantica*/ | <TEXT_SINGLE> /* semantica*/  // constante literal com "" e com ''
      | <TRUE> /* semantica*/
      | <FALSE> /* semantica*/
      | <LPAREN> Expressao() <RPAREN>
      | <EXCLAMATION> <LPAREN> Expressao() <RPAREN> /* semantica*/
    }catch (ParseException e){
        if(isEOF()){throw e;}

        errosSintaticosCount++;
        String tokensEsperados = getListaTokensEsperados(e.expectedTokenSequences);

        TokenStringBuilder.formatErroSintaticoToString(e, errosSintaticos, tokensEsperados);

        if (tokensEsperados.contains("identificador") || tokensEsperados.contains("numero inteiro") || tokensEsperados.contains("numero real") || tokensEsperados.contains("texto")
           || tokensEsperados.contains("constante logica"))
        {
            errosSintaticos.append("Erro sintático: Elemento deve pertencer ao conjunto: {'Identificador', 'Constante numérica', 'Constante numérica real', 'Constante literal', 'TRUE' ou 'FALSE'}").append("\n\n");
        }else if (tokensEsperados.contains("(") || tokensEsperados.contains(")")){
            errosSintaticos.append("Erro sintático: Elemento deve estar entre '(' e ')'").append("\n\n");
        }else if (tokensEsperados.contains("!")){
            errosSintaticos.append("Erro sintático: Elemento deve estar entre '!(' e ')'").append("\n\n");
        }
        skipToSynchronizingToken(RPAREN, RBRACKET, SET, READ, SHOW, IF, LOOP, THEN, SEMICOLON);
    }
}